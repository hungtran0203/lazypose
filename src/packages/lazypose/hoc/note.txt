const PresentationCom = (props) => {
  const { onChange, value } = props;
  return (
    <input onChange={onChange} value={value}
  )
}


const enhancer = (config) => (BaseComponent) => {
  const WrappedComponent = (props) => {
    const createdProps = {onChange: () => {}, value: ''};

    delete props.oProps;
    return (
      <BaseComponent {...props} {...createdProps} />
    )
  }

  return WrappedComponent;
}


hoc/enhancer

const enhancers = [
  withState,
  witProps,
  withAnything .....
]


ehancer(PresentationCom) => ContainerCom


withAnything(withProps(withState(PresentationCom)))

compose = (listEnahcer) => listEnahcer.rightReduce((accumluateComponent, enhacer) => {

}, null)

compose([a, b, c, d])(Pres)
  accumluateComponent = d(Pres);
  accumluateComponent = c(accumluateComponent);
  accumluateComponent = b(accumluateComponent);
  accumluateComponent = a(accumluateComponent);

a(b(c(d(Pres))))

App.js
const App = () => {
  return (
    <ContainerCom oProps={1} />
  )
}




lib recompose:
  Ehancers
    mapProps()
    withProps()
    withPropsOnChange()
    withHandlers()
    defaultProps()
    renameProp()
    renameProps()
    flattenProp()
    withState()
    withStateHandlers()
    withReducer()
    branch()
    renderComponent()
    renderNothing()
    shouldUpdate()
    pure()
    onlyUpdateForKeys()
    onlyUpdateForPropTypes()
    withContext()
    getContext()
    lifecycle()
    toClass()
    toRenderProps()
    fromRenderProps()
  Utils:
    compose()


withState(stateName, stateSetterName, initVal) =>
withState('field1Val', 'setField1Val', initVal) =>

const { field1Val, setField1Val } = props;

import { compose, withState } from 'recompose';

const COMP = compose(
  withState,
  connect(mapProps, mapDist)
)(PRESENT);


const COMP = compose(
  withState('field1', 'field1Setter'),
  withState('field2', 'field2Setter'),
  withState('field3', 'field3Setter'),
  withState('field4', 'field4Setter'),
  withState('field5', 'field5Setter'),
  withState('field6', 'field6Setter'),
  withState('field7', 'field7Setter'),
  withState('field8', 'field8Setter'),
  connect(mapProps, mapDist)
)(PRESENT);

render() {
  return <COMP />
}
FIELD1(FIELD2(FIELD3(FIELD4(FIELD5(FIELD(....))))))

current
<FIELD1WRAPPER>
  <FIELD2WRAPPER>
    <FIELD3WRAPPER>
      ...
    </FIELD3WRAPPER>
  </FIELD2WRAPPER>
</FIELD1WRAPPER>

target
<FIELDPROVIDER>
  <PRESENT />
<FIELDPROVIDER>

connect(mapProps, mapDist)(PRESENT);


recompose ======>>>>>>>>>>>>>>> lazypose

const CONTAINER =
lazypose
  .withState(...args)
  .withState(...args)
  .withState(...args)
  .withState(...args)
  .withState(...args)
  .withState(...args)
  .withPros(...args)
  .compose(PRESETNT)

enhacnerQueue = []
enhacnerQueue.push(withState)
enhacnerQueue.push(withState)
enhacnerQueue.push(withState)
enhacnerQueue.push(withState)

compose()

pose1 = lazypose
  .withState(...args)
  .withState(...args)
  .withState(...args)
  .withState(...args)
  .withState(...args)

pose2 = pose1.clone().withProps('x');

pose3 = pose1.clone().withPros('y);

pose2.compose(PRE2)
pose3.compose(PRE3)

queryBuilder = query.where(...).where(...).skip().limit().order().exec()

QUERY = "SELECT WHERE JOIN ADJ";


ReactHook
withState => useState;


target
<FIELDPROVIDER>
  <PRESENT />
<FIELDPROVIDER>



const FormX = (props) => {
  //const { field1, setFiel1 } = props;
  const [field1, setFiel1] = useState();
  const [field2, setFiel1] = useState();
  const [field3, setFiel1] = useState();



  const [field4, setFiel1] = useState();
  const [field5, setFiel1] = useState();
  return (
    <input value={field1} onChange={setField1} />
  )
}